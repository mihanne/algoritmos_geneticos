# -*- coding: utf-8 -*-
"""TPFinal3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1seKcx_eKit-2wya6vVSLcP9DfWUSNrsb
"""

# -*- coding: utf-8 -*-
"""TPFinal3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1seKcx_eKit-2wya6vVSLcP9DfWUSNrsb
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Define a classe Individual (Indivíduo)
class Individual:
    """
    Representa um indivíduo (cromossomo) na população do algoritmo genético,
    que corresponde a um conjunto de parâmetros fisiológicos do paciente.
    """
    def __init__(self, gene_count=None, initial_genes=None, patient_data=None):
        if initial_genes is not None:
            self.genes = np.array(initial_genes)
        else:
            # Se não houver genes iniciais, cria genes aleatórios (pode ser ajustado)
            self.genes = np.random.uniform(0, 100, gene_count)
        self.fitness = 0.0
        self.patient_data = patient_data # Armazena os dados completos do paciente para acesso às colunas adicionais

    def __repr__(self):
        return f"Genes: {self.genes}, Fitness: {self.fitness:.4f}"

# Classe auxiliar para calcular SOFA
class SOFACalculator:
    @staticmethod
    def calculate_sofa_score(genes):
        """
        Calcula o SOFA Score baseado nos genes (parâmetros fisiológicos).
        Os genes esperados são: [SaO2/FiO2, Platelets, Bilirubin_total, MAP, Creatinine]
        """
        sofa_score = 0
        # Garante que os genes tenham o tamanho esperado para evitar erros de índice
        if len(genes) < 5:
            return 0 # Ou levante um erro, dependendo do comportamento desejado

        sa_fi, platelets, bilirubin, map_val, creatinine = genes[0], genes[1], genes[2], genes[3], genes[4]

        # SaO2/FiO2
        if sa_fi < 67:
            sofa_score += 4
        elif 67 <= sa_fi <= 141:
            sofa_score += 3
        elif 142 <= sa_fi <= 220:
            sofa_score += 2
        elif 221 <= sa_fi <= 301:
            sofa_score += 1

        # Platelets
        if 100 <= platelets < 150:
            sofa_score += 1
        elif 50 <= platelets < 100:
            sofa_score += 2
        elif 20 <= platelets < 50:
            sofa_score += 3
        elif platelets < 20:
            sofa_score += 4

        # Bilirubin_total
        if 1.2 <= bilirubin <= 1.9:
            sofa_score += 1
        elif 1.9 < bilirubin <= 5.9:
            sofa_score += 2
        elif 5.9 < bilirubin <= 11.9:
            sofa_score += 3
        elif bilirubin > 11.9:
            sofa_score += 4

        # MAP (Mean Arterial Pressure)
        if map_val < 70:
            sofa_score += 1

        # Creatinine
        if 1.2 <= creatinine <= 1.9:
            sofa_score += 1
        elif 1.9 < creatinine <= 3.4:
            sofa_score += 2
        elif 3.4 < creatinine <= 4.9:
            sofa_score += 3
        elif creatinine > 4.9:
            sofa_score += 4

        return sofa_score

    @staticmethod
    def calculate_fitness(individual):
        """
        Calcula a aptidão (fitness) do indivíduo baseado no SOFA Score,
        NEWS Score e tempo para atuação médica.
        """
        # Verifica se os dados do paciente estão disponíveis
        if individual.patient_data is None:
            individual.fitness = 0
            print("Erro: Dados do paciente não disponíveis para cálculo de fitness.")
            return

        # Calcula o SOFA Score usando os primeiros 5 genes (parâmetros SOFA)
        sofa_score = SOFACalculator.calculate_sofa_score(individual.genes[:5])

        # Extrai os parâmetros para o cálculo do NEWS Score dos dados do paciente
        # Assumindo os nomes das colunas conforme discutido
        resp = individual.patient_data.get('Resp', 0)
        o2sat = individual.patient_data.get('O2Sat', 0)
        sbp = individual.patient_data.get('SBP', 0)
        hr = individual.patient_data.get('HR', 0)
        temp = individual.patient_data.get('Temp', 0)

        # Calcula o NEWS Score
        news_score = NEWSCalculator.calculate_news_score(resp, o2sat, sbp, hr, temp)

        # Extrai os parâmetros para o cálculo do tempo de atuação médica
        intervention_flag = individual.patient_data.get('SepsisLabel', 0)
        iculos_time = individual.patient_data.get('ICULOS', 0)
        hosp_adm_time = individual.patient_data.get('HospAdmTime', 0)

        time_to_medical_action = 0.0

        # Regras para o tempo de atuação médica
        if intervention_flag == 1 and sofa_score >= 2:
            time_to_medical_action = iculos_time - 6
        elif news_score >= 5:
            time_to_medical_action = hosp_adm_time
        else:
            # Caso nenhuma das condições seja atendida, mas uma intervenção possa ser necessária.
            # Se intervention_flag for 0, isso será penalizado abaixo.
            # Se intervention_flag for 1 mas nenhuma condição de tempo específica for atendida,
            # podemos atribuir um tempo padrão ou uma penalidade menor.
            # Por simplicidade, vamos assumir um tempo alto se nenhuma condição for explicitamente atendida
            # e não houver intervenção (será coberto pela penalidade).
            # Se intervention_flag for 1 mas as condições não se encaixam, assume-se um tempo "ideal" ou 0.
            time_to_medical_action = 0.0 # Tempo ideal se a intervenção ocorreu mas não atendeu aos critérios específicos

        # Penalidade se a coluna 41 (Intervention_Flag) for 0
        if intervention_flag == 0:
            # Adiciona uma grande penalidade se não houve intervenção quando potencialmente necessária
            # Isso fará com que o fitness seja muito baixo para esses casos
            time_to_medical_action += 1000.0 # Grande valor para penalizar

        # Garante que o tempo de atuação médica seja positivo para evitar problemas na função fitness
        if time_to_medical_action <= 0:
            time_to_medical_action = 0.1 # Um valor pequeno e positivo para evitar divisão por zero ou fitness infinito

        # A aptidão é inversamente proporcional ao tempo de atuação médica.
        # Queremos minimizar o tempo, então um tempo menor resulta em maior aptidão.
        individual.fitness = 1 / (1 + time_to_medical_action**2)

        # Garante que o fitness seja um número finito
        if not np.isfinite(individual.fitness):
            individual.fitness = 0 # Define como 0 se for infinito ou NaN

# Nova classe para calcular o Score NEWS
class NEWSCalculator:
    @staticmethod
    def calculate_resp_score(resp_val):
        """Calcula a pontuação de Respiração para o NEWS."""
        if resp_val <= 8: return 3
        elif 9 <= resp_val <= 11: return 1
        elif 12 <= resp_val <= 20: return 0
        elif 21 <= resp_val <= 24: return 2
        elif resp_val >= 25: return 3
        return 0 # Caso fora dos ranges definidos

    @staticmethod
    def calculate_o2sat_score(o2sat_val):
        """Calcula a pontuação de Saturação de O2 para o NEWS."""
        if o2sat_val <= 83: return 3
        elif 84 <= o2sat_val <= 85: return 2
        elif 86 <= o2sat_val <= 87: return 1
        elif 88 <= o2sat_val <= 92: return 0
        elif 93 <= o2sat_val <= 94: return 1
        elif 95 <= o2sat_val <= 96: return 2
        elif o2sat_val >= 97: return 3
        return 0

    @staticmethod
    def calculate_sbp_score(sbp_val):
        """Calcula a pontuação de Pressão Arterial Sistólica (SBP) para o NEWS."""
        if sbp_val <= 90: return 3
        elif 91 <= sbp_val <= 100: return 2
        elif 101 <= sbp_val <= 110: return 1
        elif 111 <= sbp_val <= 219: return 0
        elif sbp_val >= 220: return 3
        return 0

    @staticmethod
    def calculate_hr_score(hr_val):
        """Calcula a pontuação de Frequência Cardíaca (HR) para o NEWS."""
        if hr_val <= 40: return 3
        elif 41 <= hr_val <= 50: return 1
        elif 51 <= hr_val <= 90: return 0
        elif 91 <= hr_val <= 110: return 1
        elif 111 <= hr_val <= 130: return 2
        elif hr_val >= 131: return 3
        return 0

    @staticmethod
    def calculate_temp_score(temp_val):
        """Calcula a pontuação de Temperatura para o NEWS."""
        if temp_val <= 35.0: return 3
        elif 35.1 <= temp_val <= 36.0: return 1
        elif 36.1 <= temp_val <= 38.0: return 0
        elif 38.1 <= temp_val <= 39.0: return 1
        elif temp_val >= 39.1: return 2
        return 0

    @staticmethod
    def calculate_news_score(resp, o2sat, sbp, hr, temp):
        """
        Calcula o Score NEWS total somando as pontuações individuais.
        """
        score = 0
        score += NEWSCalculator.calculate_resp_score(resp)
        score += NEWSCalculator.calculate_o2sat_score(o2sat)
        score += NEWSCalculator.calculate_sbp_score(sbp)
        score += NEWSCalculator.calculate_hr_score(hr)
        score += NEWSCalculator.calculate_temp_score(temp)
        return score

# Define a classe GeneticAlgorithm (Algoritmo Genético)
class GeneticAlgorithm:
    """
    Gerencia a população e o processo de evolução.
    """
    def __init__(self, pop_size, gene_count, mutation_rate, generations, dataframe):
        self.pop_size = pop_size
        self.gene_count = gene_count
        self.mutation_rate = mutation_rate
        self.generations = generations
        self.population = []
        self.dataframe = dataframe # O dataframe completo é necessário

    def _create_initial_population(self):
        """
        Cria a população inicial de indivíduos a partir das linhas do dataframe.
        Cada indivíduo representa um conjunto de parâmetros de um paciente.
        """
        # Colunas relevantes para os genes (SOFA + NEWS)
        # Assumindo os nomes das colunas conforme discutido
        sofa_gene_cols_raw = ['SaO2', 'FiO2', 'Platelets', 'Bilirubin_total', 'MAP', 'Creatinine']
        news_gene_cols_raw = ['Resp', 'O2Sat', 'SBP', 'HR', 'Temp']
        all_gene_cols_raw = sofa_gene_cols_raw + news_gene_cols_raw

        # Outras colunas relevantes para o cálculo de fitness
        other_cols = ['SepsisLabel', 'ICULOS', 'HospAdmTime']

        # Seleciona as colunas necessárias e faz uma cópia para evitar SettingWithCopyWarning
        temp_df = self.dataframe[all_gene_cols_raw + other_cols].copy()

        # Preenchimento de valores nulos para as colunas de genes
        for col in all_gene_cols_raw:
            if temp_df[col].isnull().all():
                temp_df[col] = 1.0 # Valor padrão se a coluna inteira for nula
            else:
                temp_df[col] = temp_df[col].fillna(temp_df[col].mean()) # Preenche com a média da coluna

        # Calcula SaO2/FiO2 para SOFA
        # Garante que 'FiO2' não seja zero para evitar divisão por zero
        temp_df['SaO2/FiO2'] = temp_df['SaO2'] / (temp_df['FiO2'].replace(0, 1e-6) + 1e-6)

        self.population = []
        # Cria um indivíduo para cada linha do dataframe (paciente)
        for _, row in temp_df.iterrows():
            # Genes para cálculo do SOFA (primeiros 5)
            sofa_genes_values = [
                row['SaO2/FiO2'],
                row['Platelets'],
                row['Bilirubin_total'],
                row['MAP'],
                row['Creatinine']
            ]
            # Genes para cálculo do NEWS (próximos 5) - embora o NEWS use os valores brutos do patient_data
            # estes são incluídos nos genes para manter a consistência do `gene_count`
            news_genes_values = [
                row['Resp'],
                row['O2Sat'],
                row['SBP'],
                row['HR'],
                row['Temp']
            ]
            # Combina todos os genes
            all_genes = sofa_genes_values + news_genes_values
            self.population.append(Individual(initial_genes=all_genes, patient_data=row))

        # Se a população inicial for maior que o pop_size, trunca
        if len(self.population) > self.pop_size:
            self.population = self.population[:self.pop_size]
        # Se for menor, pode-se duplicar indivíduos ou gerar aleatoriamente para atingir pop_size
        # Por enquanto, usaremos apenas os pacientes disponíveis
        elif len(self.population) < self.pop_size:
            print(f"Aviso: Número de pacientes ({len(self.population)}) é menor que pop_size ({self.pop_size}). Usando todos os pacientes disponíveis.")
            # Opcional: Adicionar indivíduos aleatórios ou duplicar existentes para atingir pop_size
            # while len(self.population) < self.pop_size:
            #     self.population.append(Individual(gene_count=self.gene_count))


    def _crossover(self, parent1, parent2):
        """Realiza o crossover entre dois pais para criar genes de um filho."""
        child_genes = np.copy(parent1.genes)
        crossover_point = np.random.randint(1, self.gene_count - 1)
        child_genes[crossover_point:] = parent2.genes[crossover_point:]
        return child_genes

    def _mutate(self, genes):
        """Realiza a mutação nos genes de um indivíduo."""
        for i in range(self.gene_count):
            if np.random.rand() < self.mutation_rate:
                # Mutação por adição de ruído aleatório dentro de um range
                genes[i] = genes[i] + np.random.uniform(-10, 10) # Ajuste o range de mutação conforme necessário
                # Opcional: Clampar os valores dos genes dentro de limites razoáveis (e.g., 0 a 300)
                genes[i] = np.clip(genes[i], 0, 300) # Exemplo de clampeamento
        return genes

    def run(self):
        """Executa o algoritmo genético."""
        self._create_initial_population()
        stats = {
            'best_fitness': [], 'worst_fitness': [], 'avg_fitness': [],
            'best_sofa': [], 'worst_sofa': [], 'avg_sofa': [],
            'best_news': [], 'worst_news': [], 'avg_news': [], # Adicionado NEWS stats
            'news_high_no_sepsis_percent': [], # New stat
            'best_params': None,
            'avg_genes_per_gen': [],
            'best_genes_per_gen': []
        }

        # Define a porcentagem de indivíduos de elite a serem preservados
        elite_percent = 0.05
        elite_count = int(self.pop_size * elite_percent)
        if elite_count < 1 and self.pop_size > 0: # Garante que pelo menos 1 elite seja preservado se a população não for vazia
            elite_count = 1

        for generation in range(self.generations):
            # Calcula o fitness para cada indivíduo na população
            for individual in self.population:
                SOFACalculator.calculate_fitness(individual)

            # Filtra indivíduos com fitness > 0 (evita problemas com fitness 0 ou NaN)
            self.population = [ind for ind in self.population if ind.fitness > 0 and np.isfinite(ind.fitness)]
            if not self.population or len(self.population) < 2:
                print(f"Aviso: População insuficiente na geração {generation + 1}. Recriando população inicial.")
                self._create_initial_population()
                # Recalcula fitness para a nova população
                for individual in self.population:
                    SOFACalculator.calculate_fitness(individual)
                filtered_pop_after_recreate = [ind for ind in self.population if ind.fitness > 0 and np.isfinite(ind.fitness)]
                if not filtered_pop_after_recreate:
                    print(f"Aviso: População ainda vazia após recriação na geração {generation + 1}. Pulando geração.")
                    continue # Se ainda estiver vazia, pula a geração
                self.population = filtered_pop_after_recreate


            # Ordena a população por fitness (do melhor para o pior)
            self.population.sort(key=lambda x: x.fitness, reverse=True)

            # Preserva os indivíduos de elite
            elites = self.population[:elite_count]

            next_population = []
            parents_pool = self.population
            total_fitness = sum(ind.fitness for ind in parents_pool)

            if total_fitness == 0:
                probabilities = [1.0 / len(parents_pool)] * len(parents_pool)
            else:
                probabilities = [ind.fitness / total_fitness for ind in parents_pool]

            # O número de descendentes a serem gerados é a população total menos os elites
            num_offspring = self.pop_size - elite_count

            # Seleção dos pais com substituição
            # Garante que haja pais suficientes para a seleção
            if len(parents_pool) < 2:
                print(f"Aviso: Menos de 2 indivíduos na pool de pais na geração {generation + 1}. Não é possível realizar crossover.")
                # Se não houver pais suficientes, a próxima população será apenas os elites
                self.population = elites
                continue # Pula para a próxima geração

            parent_indices = np.random.choice(
                range(len(parents_pool)),
                size=num_offspring, # Seleciona pais para preencher o restante da população
                p=probabilities,
                replace=True
            )
            parents_list = [parents_pool[i] for i in parent_indices]

            # Crossover e Mutação
            for i in range(0, len(parents_list), 2):
                if i+1 < len(parents_list):
                    parent1 = parents_list[i]
                    parent2 = parents_list[i+1]
                    child1_genes = self._crossover(parent1, parent2)
                    child2_genes = self._crossover(parent2, parent1)
                    child1_genes = self._mutate(child1_genes)
                    child2_genes = self._mutate(child2_genes)
                    # Cria novos indivíduos com os genes mutados, mas mantém os dados do paciente
                    # do pai mais apto ou de um dos pais para a avaliação do fitness.
                    # Para simplificar, vamos associar os filhos com os dados do paciente do parent1
                    next_population.append(Individual(initial_genes=child1_genes, patient_data=parent1.patient_data))
                    next_population.append(Individual(initial_genes=child2_genes, patient_data=parent2.patient_data))
                elif i < len(parents_list): # Se houver um número ímpar de pais, o último é mutado
                    parent1 = parents_list[i]
                    child_genes = self._mutate(np.copy(parent1.genes))
                    next_population.append(Individual(initial_genes=child_genes, patient_data=parent1.patient_data))


            # Adiciona os elites à próxima população
            next_population.extend(elites)
            # Garante que a população não exceda o pop_size
            self.population = next_population[:self.pop_size]

            # Recalcula o fitness para a população atualizada (incluindo elites e novos descendentes)
            for individual in self.population:
                SOFACalculator.calculate_fitness(individual)

            # Re-filtra e re-ordena a população para coletar estatísticas da geração atual
            self.population = [ind for ind in self.population if ind.fitness > 0 and np.isfinite(ind.fitness)]
            if not self.population:
                print(f"Aviso: População vazia na geração {generation + 1} após elitismo e filtragem. Recriando.")
                self._create_initial_population()
                # Recalcula fitness para a nova população
                for individual in self.population:
                    SOFACalculator.calculate_fitness(individual)
                self.population = [ind for ind in self.population if ind.fitness > 0 and np.isfinite(ind.fitness)]
                if not self.population:
                    print(f"Aviso: População ainda vazia após recriação na geração {generation + 1}. Pulando geração.")
                    continue


            self.population.sort(key=lambda x: x.fitness, reverse=True)

            all_fitness = [ind.fitness for ind in self.population]
            all_sofa = [SOFACalculator.calculate_sofa_score(ind.genes[:5]) for ind in self.population] # Apenas os 5 primeiros genes para SOFA
            all_news = [NEWSCalculator.calculate_news_score(
                        ind.patient_data.get('Resp', 0),
                        ind.patient_data.get('O2Sat', 0),
                        ind.patient_data.get('SBP', 0),
                        ind.patient_data.get('HR', 0),
                        ind.patient_data.get('Temp', 0)
                    ) for ind in self.population] # NEWS usa dados brutos do paciente
            all_genes_values = np.array([ind.genes for ind in self.population])
            news_high_no_sepsis_count = 0
            for individual in self.population:
                current_news_score = NEWSCalculator.calculate_news_score(
                    individual.patient_data.get('Resp', 0),
                    individual.patient_data.get('O2Sat', 0),
                    individual.patient_data.get('SBP', 0),
                    individual.patient_data.get('HR', 0),
                    individual.patient_data.get('Temp', 0)
                )
                if current_news_score >= 5 and individual.patient_data.get('SepsisLabel', 0) == 0:
                    news_high_no_sepsis_count += 1
            news_high_no_sepsis_percent = (news_high_no_sepsis_count / len(self.population)) * 100 if len(self.population) > 0 else 0
            stats['news_high_no_sepsis_percent'].append(news_high_no_sepsis_percent)

            stats['best_fitness'].append(max(all_fitness))
            stats['worst_fitness'].append(min(all_fitness))
            stats['avg_fitness'].append(np.mean(all_fitness))
            stats['best_sofa'].append(min(all_sofa))
            stats['worst_sofa'].append(max(all_sofa))
            stats['avg_sofa'].append(np.mean(all_sofa))
            stats['best_news'].append(min(all_news)) # Adicionado NEWS stats
            stats['worst_news'].append(max(all_news)) # Adicionado NEWS stats
            stats['avg_news'].append(np.mean(all_news)) # Adicionado NEWS stats

            stats['avg_genes_per_gen'].append(np.mean(all_genes_values, axis=0))
            stats['best_genes_per_gen'].append(self.population[0].genes)

            best_individual = self.population[0]
            sofa_value = SOFACalculator.calculate_sofa_score(best_individual.genes[:5])
            news_value = NEWSCalculator.calculate_news_score(
                        best_individual.patient_data.get('Resp', 0),
                        best_individual.patient_data.get('O2Sat', 0),
                        best_individual.patient_data.get('SBP', 0),
                        best_individual.patient_data.get('HR', 0),
                        best_individual.patient_data.get('Temp', 0)
                    )
            print(f"GA Geração {generation + 1}: Melhor Aptidão = {best_individual.fitness:.4f}, SOFA = {sofa_value:.2f}, NEWS = {news_value:.2f}")


        stats['best_params'] = self.population[0].genes
        return stats

# Nova classe para o Algoritmo de Evolução Diferencial
class DifferentialEvolution:
    def __init__(self, pop_size, gene_count, cr, f, generations, dataframe):
        self.pop_size = pop_size
        self.gene_count = gene_count
        self.cr = cr  # Crossover Rate
        self.f = f    # Mutation Factor
        self.generations = generations
        self.dataframe = dataframe
        self.population = []

    def _create_initial_population(self):
        """
        Cria a população inicial de indivíduos a partir das linhas do dataframe.
        Cada indivíduo representa um conjunto de parâmetros de um paciente.
        """
        # Colunas relevantes para os genes (SOFA + NEWS)
        sofa_gene_cols_raw = ['SaO2', 'FiO2', 'Platelets', 'Bilirubin_total', 'MAP', 'Creatinine']
        news_gene_cols_raw = ['Resp', 'O2Sat', 'SBP', 'HR', 'Temp']
        all_gene_cols_raw = sofa_gene_cols_raw + news_gene_cols_raw

        # Outras colunas relevantes para o cálculo de fitness
        other_cols = ['SepsisLabel', 'ICULOS', 'HospAdmTime']

        temp_df = self.dataframe[all_gene_cols_raw + other_cols].copy()

        # Preenchimento de valores nulos para as colunas de genes
        for col in all_gene_cols_raw:
            if temp_df[col].isnull().all():
                temp_df[col] = 1.0
            else:
                temp_df[col] = temp_df[col].fillna(temp_df[col].mean())

        temp_df['SaO2/FiO2'] = temp_df['SaO2'] / (temp_df['FiO2'].replace(0, 1e-6) + 1e-6)

        self.population = []
        for _, row in temp_df.iterrows():
            sofa_genes_values = [
                row['SaO2/FiO2'],
                row['Platelets'],
                row['Bilirubin_total'],
                row['MAP'],
                row['Creatinine']
            ]
            news_genes_values = [
                row['Resp'],
                row['O2Sat'],
                row['SBP'],
                row['HR'],
                row['Temp']
            ]
            all_genes = sofa_genes_values + news_genes_values
            self.population.append(Individual(initial_genes=all_genes, patient_data=row))

        if len(self.population) > self.pop_size:
            self.population = self.population[:self.pop_size]
        elif len(self.population) < self.pop_size:
            print(f"Aviso: Número de pacientes ({len(self.population)}) é menor que pop_size ({self.pop_size}). Usando todos os pacientes disponíveis.")


    def run(self):
        """Executa o algoritmo de evolução diferencial."""
        self._create_initial_population()
        stats = {
            'best_fitness': [], 'worst_fitness': [], 'avg_fitness': [],
            'best_sofa': [], 'worst_sofa': [], 'avg_sofa': [],
            'best_news': [], 'worst_news': [], 'avg_news': [], # Adicionado NEWS stats
            'news_high_no_sepsis_percent': [], # New stat
            'best_params': None,
            'avg_genes_per_gen': [],
            'best_genes_per_gen': []
        }

        for generation in range(self.generations):
            new_population = []

            # Calcula o fitness para a população atual
            for ind in self.population:
                SOFACalculator.calculate_fitness(ind)

            # Filtra indivíduos com fitness válido para garantir operações numéricas
            filtered_population = [ind for ind in self.population if ind.fitness > 0 and np.isfinite(ind.fitness)]
            if len(filtered_population) < 4: # DE requer pelo menos 4 indivíduos para seleção de vetores
                print(f"Aviso: População insuficiente para DE na geração {generation + 1}. Recriando população inicial.")
                self._create_initial_population()
                # Recalcula fitness para a nova população
                for ind in self.population:
                    SOFACalculator.calculate_fitness(ind)
                filtered_population = [ind for ind in self.population if ind.fitness > 0 and np.isfinite(ind.fitness)]
                if len(filtered_population) < 4:
                    print("Erro: População ainda insuficiente após recriação. Abortando geração.")
                    continue # Pula a geração se a população ainda for muito pequena

            for i in range(len(filtered_population)):
                target_individual = filtered_population[i]

                # Seleciona 3 índices distintos do indivíduo alvo
                indices = [idx for idx in range(len(filtered_population)) if idx != i]
                if len(indices) < 3:
                    # Isso não deveria acontecer se filtered_population >= 4
                    print("Erro: Não foi possível selecionar 3 indivíduos distintos para DE. Pulando.")
                    new_population.append(target_individual) # Mantém o indivíduo original
                    continue

                a, b, c = np.random.choice(indices, 3, replace=False)

                # Vetor doador (mutação)
                donor_vector = filtered_population[a].genes + self.f * (filtered_population[b].genes - filtered_population[c].genes)

                # Vetor de tentativa (crossover)
                trial_vector = np.copy(target_individual.genes)
                rand_indices = np.random.rand(self.gene_count) < self.cr
                # Garante que pelo menos um gene seja do vetor doador para evitar estagnação
                if not np.any(rand_indices):
                    rand_indices[np.random.randint(0, self.gene_count)] = True
                trial_vector[rand_indices] = donor_vector[rand_indices]

                # Clampear valores do trial_vector dentro de limites razoáveis
                trial_vector = np.clip(trial_vector, 0, 300) # Exemplo de clampeamento

                # Cria um novo indivíduo de tentativa com os genes e os dados do paciente do alvo
                trial_individual = Individual(initial_genes=trial_vector, patient_data=target_individual.patient_data)
                SOFACalculator.calculate_fitness(trial_individual)

                # Seleção: se o indivíduo de tentativa for melhor, ele substitui o alvo
                if trial_individual.fitness > target_individual.fitness:
                    new_population.append(trial_individual)
                else:
                    new_population.append(target_individual)

            self.population = new_population[:self.pop_size]

            # Recalcula fitness para a nova população (garantir que todos tenham fitness atualizado)
            for individual in self.population:
                SOFACalculator.calculate_fitness(individual)
            self.population = [ind for ind in self.population if ind.fitness > 0 and np.isfinite(ind.fitness)]

            if not self.population:
                print(f"Aviso: População vazia na geração {generation + 1} após filtragem. Recriando.")
                self._create_initial_population()
                continue

            self.population.sort(key=lambda x: x.fitness, reverse=True)
            best_individual = self.population[0]

            all_fitness = [ind.fitness for ind in self.population]
            all_sofa = [SOFACalculator.calculate_sofa_score(ind.genes[:5]) for ind in self.population]
            all_news = [NEWSCalculator.calculate_news_score(
                        best_individual.patient_data.get('Resp', 0),
                        best_individual.patient_data.get('O2Sat', 0),
                        best_individual.patient_data.get('SBP', 0),
                        best_individual.patient_data.get('HR', 0),
                        best_individual.patient_data.get('Temp', 0)
                    ) for ind in self.population]
            all_genes_values = np.array([ind.genes for ind in self.population])

            news_high_no_sepsis_count = 0
            for individual in self.population:
                current_news_score = NEWSCalculator.calculate_news_score(
                    individual.patient_data.get('Resp', 0),
                    individual.patient_data.get('O2Sat', 0),
                    individual.patient_data.get('SBP', 0),
                    individual.patient_data.get('HR', 0),
                    individual.patient_data.get('Temp', 0)
                )
                if current_news_score >= 5 and individual.patient_data.get('SepsisLabel', 0) == 0:
                    news_high_no_sepsis_count += 1
            news_high_no_sepsis_percent = (news_high_no_sepsis_count / len(self.population)) * 100 if len(self.population) > 0 else 0
            stats['news_high_no_sepsis_percent'].append(news_high_no_sepsis_percent)

            stats['best_fitness'].append(max(all_fitness))
            stats['worst_fitness'].append(min(all_fitness))
            stats['avg_fitness'].append(np.mean(all_fitness))
            stats['best_sofa'].append(min(all_sofa))
            stats['worst_sofa'].append(max(all_sofa))
            stats['avg_sofa'].append(np.mean(all_sofa))
            stats['best_news'].append(min(all_news)) # Adicionado NEWS stats
            stats['worst_news'].append(max(all_news)) # Adicionado NEWS stats
            stats['avg_news'].append(np.mean(all_news)) # Adicionado NEWS stats

            stats['avg_genes_per_gen'].append(np.mean(all_genes_values, axis=0))
            stats['best_genes_per_gen'].append(self.population[0].genes)

            sofa_value = SOFACalculator.calculate_sofa_score(best_individual.genes[:5])
            news_value = NEWSCalculator.calculate_news_score(
                        best_individual.patient_data.get('Resp', 0),
                        best_individual.patient_data.get('O2Sat', 0),
                        best_individual.patient_data.get('SBP', 0),
                        best_individual.patient_data.get('HR', 0),
                        best_individual.patient_data.get('Temp', 0)
                    )
            print(f"DE Geração {generation + 1}: Melhor Aptidão = {best_individual.fitness:.4f}, SOFA = {sofa_value:.2f}, NEWS = {news_value:.2f}, Melhor Indivíduo = {best_individual.genes}")

            # Opcional: Plotar contornos a cada X gerações
            # if (generation + 1) % 14 == 0:
            #     self._plot_contour(generation + 1, best_individual.genes)

        stats['best_params'] = self.population[0].genes
        return stats

    def _plot_contour(self, generation_num, best_genes):
        """
        Função para plotar o contorno do SOFA Score.
        Esta função pode precisar de ajustes se os genes mudarem muito.
        """
        # Assumindo que os genes 3 e 4 ainda são MAP e Creatinine para esta visualização
        fixed_sa_fi = best_genes[0]
        fixed_platelets = best_genes[1]
        fixed_bilirubin = best_genes[2]

        map_range = np.linspace(50, 100, 50)
        creatinine_range = np.linspace(0.5, 5.5, 50)

        X, Y = np.meshgrid(map_range, creatinine_range)
        Z = np.zeros(X.shape)

        for i in range(X.shape[0]):
            for j in range(X.shape[1]):
                # Apenas os genes SOFA são usados para esta plotagem
                temp_sofa_genes = np.array([fixed_sa_fi, fixed_platelets, fixed_bilirubin, X[i, j], Y[i, j]])
                Z[i, j] = SOFACalculator.calculate_sofa_score(temp_sofa_genes)

        plt.figure(figsize=(10, 8))
        contour = plt.contourf(X, Y, Z, levels=range(0, 10), cmap='viridis', alpha=0.8)
        plt.colorbar(contour, label='SOFA Score')

        # Extrai os genes MAP e Creatinine da população atual para plotagem
        current_map_genes = [ind.genes[3] for ind in self.population]
        current_creatinine_genes = [ind.genes[4] for ind in self.population]
        plt.scatter(current_map_genes, current_creatinine_genes, color='red', s=50, edgecolors='black', label='População Atual')

        plt.scatter(best_genes[3], best_genes[4], color='cyan', s=200, marker='*', edgecolors='black', label='Melhor Indivíduo')


        plt.title(f'Curva de Nível do SOFA (Geração {generation_num}) - DE')
        plt.xlabel('MAP (mm Hg)')
        plt.ylabel('Creatinine (mg/dL)')
        plt.legend()
        plt.grid(True)
        plt.savefig(f'/content/drive/MyDrive/Colab Notebooks/TPFinal_CompEvolutiva/de_contour_gen_{generation_num:03d}.png')
        plt.close()

# --- Execução do Algoritmo ---
if __name__ == "__main__":
    # Carrega o arquivo de dados
    # Certifique-se de que o caminho do arquivo está correto
    try:
        df = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/TPFinal_CompEvolutiva/septicos_dados.csv')
        print("Dados do paciente carregados para referência.")
        print(df.head())
    except FileNotFoundError:
        print("Erro: Arquivo 'septicos_dados.csv' não encontrado. Por favor, verifique o caminho.")
        exit() # Sai do programa se o arquivo não for encontrado

    # Parâmetros do algoritmo
    pop_size = 100
    # O gene_count agora inclui os 5 parâmetros SOFA + 5 parâmetros NEWS
    gene_count = 10
    mutation_rate = 0.3
    generations = 100
    num_executions = 30

    # Nomes dos genes para os gráficos (SOFA + NEWS)
    gene_names = ['SaO2/FiO2', 'Platelets', 'Bilirubin_total', 'MAP', 'Creatinine',
                  'Resp', 'O2Sat', 'SBP', 'HR', 'Temp']

    # --- Execução do Algoritmo Genético ---
    print("\nExecutando o Algoritmo Genético...")
    all_ga_best_fitness = np.zeros((num_executions, generations))
    all_ga_worst_fitness = np.zeros((num_executions, generations))
    all_ga_avg_fitness = np.zeros((num_executions, generations))
    all_ga_avg_sofa = np.zeros((num_executions, generations))
    all_ga_avg_news = np.zeros((num_executions, generations)) # Adicionado NEWS stats
    all_ga_avg_genes = np.zeros((num_executions, generations, gene_count))
    all_ga_best_genes = np.zeros((num_executions, generations, gene_count))
    all_ga_news_high_no_sepsis_percent = np.zeros((num_executions, generations))

    for i in range(num_executions):
        ga = GeneticAlgorithm(pop_size, gene_count, mutation_rate=0.1, generations=generations, dataframe=df)
        run_stats = ga.run()
        all_ga_best_fitness[i, :] = run_stats['best_fitness']
        all_ga_worst_fitness[i, :] = run_stats['worst_fitness']
        all_ga_avg_fitness[i, :] = run_stats['avg_fitness']
        all_ga_avg_sofa[i, :] = run_stats['avg_sofa']
        all_ga_avg_news[i, :] = run_stats['avg_news'] # Adicionado NEWS stats
        all_ga_avg_genes[i, :, :] = np.array(run_stats['avg_genes_per_gen'])
        all_ga_best_genes[i, :, :] = np.array(run_stats['best_genes_per_gen'])
        all_ga_news_high_no_sepsis_percent[i, :] = np.array(run_stats['news_high_no_sepsis_percent'])
        print(f"\n--- GA Execução {i+1} concluída. ---")

    # Cálculo das estatísticas globais para o GA
    ga_overall_best_fitness = np.max(all_ga_best_fitness)
    ga_overall_worst_fitness = np.min(all_ga_worst_fitness[all_ga_worst_fitness > 0]) # Ignora fitness 0
    ga_overall_mean_fitness = np.mean(all_ga_avg_fitness)
    ga_overall_std_avg_fitness = np.mean(np.std(all_ga_avg_fitness, axis=0)) # Desvio padrão da média fitness por geração
    ga_overall_mean_news_high_no_sepsis = np.mean(all_ga_news_high_no_sepsis_percent)

    # Geração dos gráficos do GA
    generations_axis = np.arange(generations)

    plt.figure(figsize=(10, 6))
    plt.plot(generations_axis, np.mean(all_ga_avg_fitness, axis=0), label='Média de Fitness', color='blue')
    plt.plot(generations_axis, np.mean(all_ga_best_fitness, axis=0), label='Melhor Fitness (Média)', color='green', linestyle='--')
    plt.plot(generations_axis, np.mean(all_ga_worst_fitness, axis=0), label='Pior Fitness (Média)', color='red', linestyle=':')
    plt.title('Evolução da Aptidão por Geração (GA)')
    plt.xlabel('Geração')
    plt.ylabel('Aptidão')
    plt.grid(True)
    plt.legend()
    plt.savefig('/content/drive/MyDrive/Colab Notebooks/TPFinal_CompEvolutiva/ga_media_fitness.png')
    plt.close()

    plt.figure(figsize=(10, 6))
    plt.plot(generations_axis, np.std(all_ga_avg_fitness, axis=0), label='Desvio Padrão de Fitness', color='red')
    plt.title('Evolução do Desvio Padrão da Aptidão por Geração (GA)')
    plt.xlabel('Geração')
    plt.ylabel('Desvio Padrão')
    plt.grid(True)
    plt.legend()
    plt.savefig('/content/drive/MyDrive/Colab Notebooks/TPFinal_CompEvolutiva/ga_desvio_padrao_fitness.png')
    plt.close()

    plt.figure(figsize=(10, 6))
    plt.plot(generations_axis, np.mean(all_ga_avg_sofa, axis=0), label='SOFA Médio', color='purple')
    plt.title('SOFA Médio por Geração (GA)')
    plt.xlabel('Geração')
    plt.ylabel('SOFA Médio')
    plt.grid(True)
    plt.legend()
    plt.savefig('/content/drive/MyDrive/Colab Notebooks/TPFinal_CompEvolutiva/ga_media_sofa.png')
    plt.close()

    plt.figure(figsize=(10, 6))
    plt.plot(generations_axis, np.mean(all_ga_avg_news, axis=0), label='NEWS Médio', color='orange')
    plt.title('NEWS Médio por Geração (GA)')
    plt.xlabel('Geração')
    plt.ylabel('NEWS Médio')
    plt.grid(True)
    plt.legend()
    plt.savefig('/content/drive/MyDrive/Colab Notebooks/TPFinal_CompEvolutiva/ga_media_news.png')
    plt.close()

    # Gráficos de Tendência de Parâmetros (GA)
    # for j in range(gene_count):
    #     plt.figure(figsize=(10, 6))
    #     plt.plot(generations_axis, np.mean(all_ga_avg_genes[:, :, j], axis=0), label=f'Média {gene_names[j]}', color='blue')
    #     plt.plot(generations_axis, np.mean(all_ga_best_genes[:, :, j], axis=0), label=f'Melhor {gene_names[j]}', color='green', linestyle='--')
    #     plt.title(f'Tendência do Parâmetro {gene_names[j]} por Geração (GA)')
    #     plt.xlabel('Geração')
    #     plt.ylabel(f'Valor {gene_names[j]}')
    #     plt.grid(True)
    #     plt.legend()
    #     plt.savefig(f'/content/drive/MyDrive/Colab Notebooks/TPFinal_CompEvolutiva/ga_gene_{gene_names[j].replace("/", "_")}_tendencia.png')
    #     plt.close()

    # Execução do Algoritmo de Evolução Diferencial
    print("\nExecutando o Algoritmo de Evolução Diferencial...")
    all_de_best_fitness = np.zeros((num_executions, generations))
    all_de_worst_fitness = np.zeros((num_executions, generations))
    all_de_avg_fitness = np.zeros((num_executions, generations))
    all_de_avg_sofa = np.zeros((num_executions, generations))
    all_de_avg_news = np.zeros((num_executions, generations)) # Adicionado NEWS stats
    all_de_avg_genes = np.zeros((num_executions, generations, gene_count))
    all_de_best_genes = np.zeros((num_executions, generations, gene_count))
    all_de_news_high_no_sepsis_percent = np.zeros((num_executions, generations))

    for i in range(num_executions):
        de = DifferentialEvolution(pop_size, gene_count, cr=0.9, f=0.8, generations=generations, dataframe=df)
        run_stats = de.run()
        all_de_best_fitness[i, :] = run_stats['best_fitness']
        all_de_worst_fitness[i, :] = run_stats['worst_fitness']
        all_de_avg_fitness[i, :] = run_stats['avg_fitness']
        all_de_avg_sofa[i, :] = run_stats['avg_sofa']
        all_de_avg_news[i, :] = run_stats['avg_news'] # Adicionado NEWS stats
        all_de_avg_genes[i, :, :] = np.array(run_stats['avg_genes_per_gen'])
        all_de_best_genes[i, :, :] = np.array(run_stats['best_genes_per_gen'])
        all_de_news_high_no_sepsis_percent[i, :] = np.array(run_stats['news_high_no_sepsis_percent'])
        print(f"\n--- DE Execução {i+1} concluída. ---")

    # Cálculo das estatísticas globais para o DE
    de_overall_best_fitness = np.max(all_de_best_fitness)
    de_overall_worst_fitness = np.min(all_de_worst_fitness[all_de_worst_fitness > 0]) # Ignora fitness 0
    de_overall_mean_fitness = np.mean(all_de_avg_fitness)
    de_overall_std_avg_fitness = np.mean(np.std(all_de_avg_fitness, axis=0)) # Desvio padrão da média fitness por geração
    de_overall_mean_news_high_no_sepsis = np.mean(all_de_news_high_no_sepsis_percent)

    # Geração dos gráficos do DE
    plt.figure(figsize=(10, 6))
    plt.plot(generations_axis, np.mean(all_de_avg_fitness, axis=0), label='Média de Fitness', color='blue')
    plt.plot(generations_axis, np.mean(all_de_best_fitness, axis=0), label='Melhor Fitness (Média)', color='green', linestyle='--')
    plt.plot(generations_axis, np.mean(all_de_worst_fitness, axis=0), label='Pior Fitness (Média)', color='red', linestyle=':')
    plt.title('Evolução da Aptidão por Geração (DE)')
    plt.xlabel('Geração')
    plt.ylabel('Aptidão')
    plt.grid(True)
    plt.legend()
    plt.savefig('/content/drive/MyDrive/Colab Notebooks/TPFinal_CompEvolutiva/de_media_fitness.png')
    plt.close()

    plt.figure(figsize=(10, 6))
    plt.plot(generations_axis, np.std(all_de_avg_fitness, axis=0), label='Desvio Padrão de Fitness', color='red')
    plt.title('Evolução do Desvio Padrão de Fitness por Geração (DE)')
    plt.xlabel('Geração')
    plt.ylabel('Desvio Padrão')
    plt.grid(True)
    plt.legend()
    plt.savefig('/content/drive/MyDrive/Colab Notebooks/TPFinal_CompEvolutiva/de_desvio_padrao_fitness.png')
    plt.close()

    plt.figure(figsize=(10, 6))
    plt.plot(generations_axis, np.mean(all_de_avg_sofa, axis=0), label='SOFA Médio', color='purple')
    plt.title('SOFA Médio por Geração (DE)')
    plt.xlabel('Geração')
    plt.ylabel('SOFA Médio')
    plt.grid(True)
    plt.legend()
    plt.savefig('/content/drive/MyDrive/Colab Notebooks/TPFinal_CompEvolutiva/de_media_sofa.png')
    plt.close()

    plt.figure(figsize=(10, 6))
    plt.plot(generations_axis, np.mean(all_de_avg_news, axis=0), label='NEWS Médio', color='orange')
    plt.title('NEWS Médio por Geração (DE)')
    plt.xlabel('Geração')
    plt.ylabel('NEWS Médio')
    plt.grid(True)
    plt.legend()
    plt.savefig('/content/drive/MyDrive/Colab Notebooks/TPFinal_CompEvolutiva/de_media_news.png')
    plt.close()

    # # Gráficos de Tendência de Parâmetros (DE)
    # for j in range(gene_count):
    #     plt.figure(figsize=(10, 6))
    #     plt.plot(generations_axis, np.mean(all_de_avg_genes[:, :, j], axis=0), label=f'Média {gene_names[j]}', color='blue')
    #     plt.plot(generations_axis, np.mean(all_de_best_genes[:, :, j], axis=0), label=f'Melhor {gene_names[j]}', color='green', linestyle='--')
    #     plt.title(f'Tendência do Parâmetro {gene_names[j]} por Geração (DE)')
    #     plt.xlabel('Geração')
    #     plt.ylabel(f'Valor {gene_names[j]}')
    #     plt.grid(True)
    #     plt.legend()
    #     plt.savefig(f'/content/drive/MyDrive/Colab Notebooks/TPFinal_CompEvolutiva/de_gene_{gene_names[j].replace("/", "_")}_tendencia.png')
    #     plt.close()

   # Gráfico Boxplot dos resultados acumulados de fitness (melhor fitness por geração em todas as execuções)
    # plt.figure(figsize=(8, 6))
    # # Flatten os arrays para incluir todos os valores de melhor fitness de cada geração e execução
    # data_to_plot = [np.concatenate((all_ga_worst_fitness.flatten(), all_ga_best_fitness.flatten())),
    #                   np.concatenate((all_de_worst_fitness.flatten(), all_de_best_fitness.flatten()))]
    # plt.boxplot(data_to_plot, labels=['Algoritmo Genético (GA)', 'Evolução Diferencial (DE)'])
    # plt.title('Comparação da Distribuição de Aptidão (Fitness) Acumulada')
    # plt.ylabel('Melhor Aptidão por Geração')
    # plt.grid(True)
    # plt.savefig('/content/drive/MyDrive/Colab Notebooks/TPFinal_CompEvolutiva/comparacao_fitness_boxplot_acumulado.png')
    # plt.close()

    print("\n\n--- Resumo Estatístico da Aptidão (Fitness) ---")
    print("-" * 50)
    print(f"{'Métrica':<25} | {'Algoritmo Genético (GA)':<25} | {'Evolução Diferencial (DE)':<25}")
    print("-" * 80)
    print(f"{'Melhor Fitness (Geral)':<25} | {ga_overall_best_fitness:<25.4f} | {de_overall_best_fitness:<25.4f}")
    print(f"{'Pior Fitness (Geral)':<25} | {ga_overall_worst_fitness:<25.4f} | {de_overall_worst_fitness:<25.4f}")
    print(f"{'Média Fitness (Geral)':<25} | {ga_overall_mean_fitness:<25.4f} | {de_overall_mean_fitness:<25.4f}")
    print(f"{'Desvio Padrão da Média Fitness':<25} | {ga_overall_std_avg_fitness:<25.4f} | {de_overall_std_avg_fitness:<25.4f}")
    print(f"{'% NEWS >= 5 e SepsisLabel=0':<25} | {ga_overall_mean_news_high_no_sepsis:<25.4f} | {de_overall_mean_news_high_no_sepsis:<25.4f}")
    print("-" * 80)


    print("\nAnálise concluída. Gráficos do GA e DE gerados e salvos como .png.")
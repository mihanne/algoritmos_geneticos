# -*- coding: utf-8 -*-
"""Algoritmo Genético -TP1

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FwPf-wzY5vcrZYX7jxcRExtROdwD9wTq
"""

import random
import matplotlib.pyplot as plt
from google.colab import drive
import numpy as np # Importar numpy para cálculo da média e regressão
import time

# Monta o Google Drive para acesso aos arquivos
try:
    drive.mount('/content/drive')
except:
    print("Google Drive já montada ou erro ao montar.")


# Representa um item com peso e valor
class Item:
    def __init__(self, nome, peso, valor):
        self.nome = nome
        self.peso = peso
        self.valor = valor

# Representa um indivíduo (solução candidata)
class Individuo:
    def __init__(self, itens, capacidade, genes=None):
        self.itens = itens
        self.capacidade = capacidade
        if genes:
            self.genes = genes
        else:
            self.genes = self._gerar_genes_validos()
        self.avaliar_fitness()

    def _gerar_genes_validos(self):
      # vetor das variáveis
        genes = [0] * len(self.itens)
        indices = list(range(len(self.itens)))
        random.shuffle(indices)
        peso_total = 0

        for i in indices:
            if peso_total + self.itens[i].peso <= self.capacidade:
                genes[i] = 1
                peso_total += self.itens[i].peso

        return genes

    def avaliar_fitness(self):
      # avaliar só quem precisa avaliar
        self.peso_total = sum(item.peso for item, g in zip(self.itens, self.genes) if g)
        self.valor_total = sum(item.valor for item, g in zip(self.itens, self.genes) if g)
        self.fitness = self.valor_total if self.peso_total <= self.capacidade else 0

   # taxa de cruzamento por casal
    def crossover(self, outro):
        # Escolhe aleatoriamente um ponto de corte entre 1 e o tamanho dos genes - 1.
        ponto = random.randint(1, len(self.genes) - 1)

        # Cria o primeiro filho, pegando os genes do início do self até o ponto de corte e depois os genes do outro indivíduo (outro) do ponto até o final.
        filho1_genes = self.genes[:ponto] + outro.genes[ponto:]

        # Cria o segundo filho, pegando os genes do início do outro até o ponto de corte e depois os genes do self do ponto até o final.
        filho2_genes = outro.genes[:ponto] + self.genes[ponto:]

        return Individuo(self.itens, self.capacidade, filho1_genes), Individuo(self.itens, self.capacidade, filho2_genes)

    # fazer a forma dinâmica da mutação
    # a taxa de mutação influencia a mutação de cada individuo
    def mutar(self, taxa_mutacao):
        novos_genes = [1 - g if random.random() < taxa_mutacao else g for g in self.genes]
        self.genes = novos_genes
        self.avaliar_fitness()

    def corrigir(self):
        while self.peso_total > self.capacidade:
            ativos = [i for i, g in enumerate(self.genes) if g == 1]
            if not ativos:
                break
            i = random.choice(ativos)
            self.genes[i] = 0
            self.avaliar_fitness()

# População de indivíduos
class Populacao:
  # codificar no formato de binário são 40 variaveis
    def __init__(self, tamanho, itens, capacidade):
        self.itens = itens
        self.capacidade = capacidade
        self.tamanho = tamanho
        self.individuos = [Individuo(itens, capacidade) for _ in range(tamanho)]

    def selecao(self):
        candidatos_validos = [ind for ind in self.individuos if ind.peso_total <= self.capacidade]
        candidatos_validos = sorted(candidatos_validos, key=lambda ind: ind.fitness, reverse=True)
        return candidatos_validos[:2] if len(candidatos_validos) >= 2 else sorted(self.individuos, key=lambda ind: ind.fitness, reverse=True)[:2]

    # Adicionado parâmetro para o número de elites
    def nova_geracao(self, taxa_crossover=0.8, num_elites=1):
        nova_pop = []
        # Garante que o número de elites não exceda o tamanho da população
        num_elites = min(num_elites, self.tamanho)

        # Adiciona os indivíduos de elite à nova população
        elite = sorted(self.individuos, key=lambda ind: ind.fitness, reverse=True)[:num_elites]
        nova_pop.extend(elite)

        # Gera o restante da população através de seleção, crossover e mutação
        while len(nova_pop) < self.tamanho:
            pais = self.selecao()
            # aplicar a taxa de cruzamento por casal
            if random.random() < taxa_crossover: # Verifica se o crossover deve ocorrer
                filhos = pais[0].crossover(pais[1])
            else: # Se não houver crossover, os filhos são cópias dos pais
                filhos = (Individuo(self.itens, self.capacidade, list(pais[0].genes)),
                          Individuo(self.itens, self.capacidade, list(pais[1].genes)))


            for filho in filhos:
                filho.mutar(taxa_mutacao=0.2)
                filho.corrigir()
                nova_pop.append(filho)
                if len(nova_pop) >= self.tamanho:
                    break
    # criterios para a escolha do melhor individuo
        self.individuos = sorted(nova_pop, key=lambda ind: ind.fitness, reverse=True)[:self.tamanho]

    def melhor_individuo(self):
        return max(self.individuos, key=lambda ind: ind.fitness)

# Carrega dados do arquivo
def carregar_dados(caminho):
    with open(caminho, 'r') as f:
        capacidade = int(f.readline())
        num_itens = int(f.readline())
        itens = []
        for linha in f:
            nome, peso, valor = linha.strip().split(',')
            itens.append(Item(nome, int(peso), int(valor)))
    return capacidade, itens

# Algoritmo genético
# Adicionado parâmetro para o número de elites
def algoritmo_genetico(caminho_arquivo, tam_populacao=50, max_geracoes=10, taxa_crossover=0.8, num_elites=1):
    random.seed()
    capacidade, itens = carregar_dados(caminho_arquivo)
    populacao = Populacao(tam_populacao, itens, capacidade)

    melhor_fitness = 0
    geracoes_sem_melhora = 0
    historico = []

    for geracao in range(max_geracoes):
        # Passa a taxa de crossover e o número de elites para nova_geracao
        populacao.nova_geracao(taxa_crossover, num_elites)
        melhor = populacao.melhor_individuo()

        historico.append([geracao + 1, melhor.fitness, melhor.peso_total])

        # if melhor.fitness > melhor_fitness:
        #     melhor_fitness = melhor.fitness
        #     geracoes_sem_melhora = 0
        # else:
        #     geracoes_sem_melhora += 1

        print(f"Geração {geracao + 1}: Melhor valor = {melhor.fitness}, Peso = {melhor.peso_total}")

       # if geracoes_sem_melhora >= 10:
        #    break

    # Retorna o melhor indivíduo e o histórico
    return populacao.melhor_individuo(), historico

def main():
  # Execução
  numero_execucoes = 30
  taxa_crossover_ag = 0.8 # Define a taxa de crossover para as execuções
  num_elites_ag = 1 # Define o número de indivíduos de elite a serem preservados

  todos_historicos = [] # Lista para armazenar o histórico de cada execução

  print(f"Executando o Algoritmo Genético {numero_execucoes} vezes com taxa de crossover {taxa_crossover_ag} e {num_elites_ag} elites...")

  # --- Início do contador de tempo ---
  start_time = time.perf_counter()

  for i in range(numero_execucoes):
    print("Execução", i+1)
    # Captura o melhor indivíduo e o histórico retornado pela função, passando a taxa de crossover e o número de elites
    melhor, historico_execucao = algoritmo_genetico('/content/drive/MyDrive/Colab Notebooks/TP1_AG_Problema_Mochila/dados/KNAPDATA10000.TXT', taxa_crossover=taxa_crossover_ag, num_elites=num_elites_ag)
    todos_historicos.append(historico_execucao) # Armazena o histórico desta execução

    print("Melhor solução encontrada:")
    print(f"Valor total: {melhor.fitness}")
    print(f"Peso total: {melhor.peso_total} de {melhor.capacidade}")
    print("Itens selecionados:")

    for item, gene in zip(melhor.itens, melhor.genes):
              if gene:
                print(f"- {item.nome} (peso={item.peso}, valor={item.valor})")

# --- Início do cálculo e exibição do tempo de execução ---
    end_time = time.perf_counter()
    total_time = end_time - start_time
    print(f"\n--- Tempo de Execução Total ---")
    print(f"O algoritmo levou {total_time:.2f} segundos para completar {numero_execucoes} execuções.")
    # --- Fim do cálculo e exibição do tempo de execução ---

  # Calcular a média de fitness por geração
  # Verifica se há históricos para processar
  if todos_historicos:
      max_geracoes = len(todos_historicos[0]) # Assume que todas as execuções têm o mesmo número de gerações
      medias_por_geracao = [0] * max_geracoes

      for geracao in range(max_geracoes):
          soma_fitness = 0
          for historico_execucao in todos_historicos:
              # Acessa o fitness (índice 1) do histórico da geração atual
              soma_fitness += historico_execucao[geracao][1]
          medias_por_geracao[geracao] = soma_fitness / numero_execucoes

    # Gerar o gráfico
      geracoes = range(1, max_geracoes + 1)
      plt.figure(figsize=(10, 6))
      plt.plot(geracoes, medias_por_geracao)
      plt.xlabel("Geração")
      plt.ylabel("Média de Fitness")
      plt.title("Evolução da Média de Fitness por Geração")
      plt.grid(True)
      plt.show()


      # Gerar o gráfico com a curva de tendência
      geracoes = np.arange(1, max_geracoes + 1) # Gera um array numpy para as gerações

      # Calcula a regressão polinomial com grau 3 para melhor ajuste à tendência de convergência
      # np.polyfit(x, y, grau)
      coeficientes = np.polyfit(geracoes, medias_por_geracao, 2) # Alterado o grau para 3
      polinomio = np.poly1d(coeficientes)

      # Gera os valores da curva de tendência
      curva_tendencia = polinomio(geracoes)


      plt.figure(figsize=(10, 6))
      # Plota os pontos da média por geração
      plt.plot(geracoes, medias_por_geracao, 'o', label='Média por Geração')
      # Plota a curva de tendência
      plt.plot(geracoes, curva_tendencia, '-', label='Curva de Tendência', color='red') # Atualizado o label

      plt.xlabel("Geração")
      plt.ylabel("Média de Fitness")
      plt.title("Evolução da Média de Fitness por Geração com Curva de Tendência")
      plt.grid(True)
      plt.legend() # Adiciona legenda para identificar as curvas
      plt.show()
  else:
      print("Nenhum histórico de execução disponível para gerar o gráfico.")




  #geração do segundo gráfico
  # Calcular a média, o melhor e o pior fitness por geração
  if todos_historicos:
      max_geracoes = len(todos_historicos[0])  # Assume que todas as execuções têm o mesmo número de gerações
      medias_por_geracao = [0] * max_geracoes
      melhores_por_geracao = [float('-inf')] * max_geracoes
      piores_por_geracao = [float('inf')] * max_geracoes
      desvios_por_geracao = [0] * max_geracoes

      for geracao in range(max_geracoes):
          soma_fitness = 0
          for historico_execucao in todos_historicos:
              fitness = historico_execucao[geracao][1]
              soma_fitness += fitness
              if fitness > melhores_por_geracao[geracao]:
                  melhores_por_geracao[geracao] = fitness
              if fitness < piores_por_geracao[geracao]:
                  piores_por_geracao[geracao] = fitness
          medias_por_geracao[geracao] = soma_fitness / numero_execucoes

      # Gerar o gráfico com a curva de tendência
      geracoes = np.arange(1, max_geracoes + 1)

      # Calcula a regressão polinomial (grau 2) sobre a média
      coeficientes = np.polyfit(geracoes, medias_por_geracao, 2)
      polinomio = np.poly1d(coeficientes)
      curva_tendencia = polinomio(geracoes)

      # Plotagem
      plt.figure(figsize=(10, 6))
      #plt.plot(geracoes, medias_por_geracao, 'o', label='Média por Geração')
      plt.plot(geracoes, curva_tendencia, '-', label='Curva de Tendência', color='red')
      plt.plot(geracoes, melhores_por_geracao, '-', label='Melhor por Geração', color='green')
      plt.plot(geracoes, piores_por_geracao, '-', label='Pior por Geração', color='orange')

      plt.xlabel("Geração")
      plt.ylabel("Fitness")
      plt.title("Evolução do Fitness por Geração")
      plt.grid(True)
      plt.legend()
      plt.show()
  else:
      print("Nenhum histórico de execução disponível para gerar o gráfico.")


      # --- Início do código para o gráfico de Desvio Padrão por Geração ---
  if todos_historicos:
      max_geracoes = len(todos_historicos[0]) # Assume que todas as execuções têm o mesmo número de gerações
      desvios_por_geracao = []

      for geracao in range(max_geracoes):
          fitness_geracao_atual = []
          for historico_execucao in todos_historicos:
              # Coleta o fitness da geração atual de cada execução
              fitness_geracao_atual.append(historico_execucao[geracao][1])

          # Calcula o desvio padrão dos fitness para a geração atual
          desvio_padrao = np.std(fitness_geracao_atual)
          desvios_por_geracao.append(desvio_padrao)

      # Gerar o gráfico de Desvio Padrão por Geração
      geracoes = np.arange(1, max_geracoes + 1)

      plt.figure(figsize=(10, 6))
      plt.plot(geracoes, desvios_por_geracao, '-', label='Desvio Padrão por Geração', color='purple')

      plt.xlabel("Geração")
      plt.ylabel("Desvio Padrão do Fitness")
      plt.title("Evolução do Desvio Padrão do Fitness por Geração")
      plt.grid(True)
      plt.legend()
      plt.show()
  else:
      print("Nenhum histórico de execução disponível para gerar o gráfico de desvio padrão.")
# --- Fim do código para o gráfico de Desvio Padrão por Geração ---


# Estatísticas finais
      melhor_fitness = max(todos_historicos)
      pior_fitness = min(todos_historicos)
      media_fitness = np.mean(todos_historicos)
      desvio_fitness = np.std(todos_historicos)
      # Encontrar os indivíduos correspondentes
      indice_melhor = todos_historicos.index(melhor_fitness)
      indice_pior = todos_historicos.index(pior_fitness)
      melhor_individuo = todos_historicos[indice_melhor]
      pior_individuo = todos_historicos[indice_pior]
      itens=todos_historicos
      print(f"\n--- Estatísticas Finais ---")
      print(f"Melhor fitness: {melhor_fitness}")
      # print("Itens na melhor mochila:")
      # for idx, gene in enumerate(melhor_individuo):
      #     if gene == 1:
      #         print(f"  - {itens[idx][0]} (peso: {itens[idx][1]}, valor: {itens[idx][2]})")

      print(f"\nPior fitness: {pior_fitness}")
      # print("Itens na pior mochila:")
      # for idx, gene in enumerate(pior_individuo):
      #     if gene == 1:
      #         print(f"  - {itens[idx][0]} (peso: {itens[idx][1]}, valor: {itens[idx][2]})")

      print(f"\nMédia de fitness: {media_fitness:.2f}")
      print(f"Desvio padrão do fitness: {desvio_fitness:.2f}")

  #gráfico 3 blox-plot
  # Extrair o último fitness de cada execução
  if todos_historicos:
      ultimos_fitness = [execucao[-1][1] for execucao in todos_historicos]
      dados = np.array(ultimos_fitness)
      # Cálculo dos quartis e limites
      q1 = np.percentile(dados, 25)
      q3 = np.percentile(dados, 75)
      iqr = q3 - q1
      limite_inferior = q1 - 1.5 * iqr
      limite_superior = q3 + 1.5 * iqr

      # Identificar outliers
      outliers = dados[(dados < limite_inferior) | (dados > limite_superior)]
      print("Outliers detectados:", outliers.tolist())
      # Gerar o boxplot
      plt.figure(figsize=(8, 6))
      plt.boxplot(ultimos_fitness, vert=True, patch_artist=True, tick_labels=["Última Geração"])
      plt.title("Distribuição da última Fitness de cada Execução")
      plt.ylabel("Fitness")
      plt.grid(True)
      plt.show()
  else:
      print("Nenhum histórico de execução disponível para gerar o gráfico.")

if __name__ == "__main__":
    main()